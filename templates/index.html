<html>
  <head>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.3.13/d3.js" ></script>
    <style>
	.axis line, .axis path {
		fill: none;
		stroke: #111;
	}
	.y.axis path {
		display: none;
	}
	.tick line {
		stroke-dasharray: 5,5;
	}
	
	.event .connector {
		stroke-width: 1;
		stroke: #888;
	}

    </style>
  </head>
  <body>
  <svg id=timeline > 
  </svg>
  <script>
    var url = "/data"
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.open("GET", url, false);
    xmlHttp.send(null);
    var tFormat = d3.time.format("%Y-%m");
    var testData = JSON.parse(xmlHttp.responseText, function(key, value){
      if (key === "date") {
        return tFormat.parse(value);
      } else {
        return value
      }
    });

    var data = testData;

    categories = findCategories(data);		
    categories.push("none");
    categories.reverse();

    chart = d3.select('#timeline');
    margin = {top: 10, left: 100, bottom: 30, right: 10};
    height = 200 - margin.top - margin.bottom; //inner height
    width = 500 - margin.left - margin.right;  // inner width
    
    chart = chart
	.attr('width', width + margin.left + margin.right)
	.attr('height', height + margin.top + margin.bottom)
      .append('g')
	.attr('class', 'innerChart')
	.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    minDate = d3.min(data, function(obj){ return obj.date });
    maxDate = d3.max(data, function(obj){ return obj.date });

    //X axis
    tScale = d3.time.scale()
	.domain([minDate, maxDate])
	.range([10,width-10]);

    xAxis = d3.svg.axis()
	.scale(tScale)
	.orient("bottom")
	.outerTickSize(0);

    chart.append('g')
	.attr('class', 'x axis')
	.attr('transform', 'translate(0,' + height + ')')
	.call(xAxis);
       
    //Y axis
    catScale = d3.scale.ordinal()
	.domain(categories)
	.rangePoints([0, height - 15], .3);

    yAxis = d3.svg.axis()
	.scale(catScale)
	.orient('left')
	.innerTickSize(-width);

    chart.append('g')
	.attr('class', 'y axis')
	.call(yAxis); 

    //fun
    colors = d3.scale.category20()
	.domain(categories);

     //Binding data to graph

   var gEvents = chart.selectAll('.event')
	.data(data)
      .enter().append('g')
	.attr('class', 'event')

   function addIssueCircle(select, event, issue) {
	 select.append('circle')
		.attr('r', 5)
		.attr('cy', catScale(issue))
		.attr('cx', tScale(event.date))
		.style('fill', colors(issue));
	}

    function addMainCircle(select, event) {
	select.append('circle')
		.attr('r', 3)
		.attr('cy', catScale('none'))
		.attr('cx', tScale(event.date));
    }

    gEvents.each(function (event, i) {
		select = d3.select(this);
		
		event.issues.forEach(function(issue){
		     if (categories.indexOf(issue) != -1) {
			     var x = tScale(event.date);
			     select.append('line')
				.attr('class', 'connector')
				.attr('x1', x)
				.attr('x2', x)
				.attr('y1', catScale("none"))
				.attr('y2', catScale(issue))
			     select.call(addIssueCircle, event, issue);
	             }
		});
	     select.call(addMainCircle, event);
	});

   function findCategories(data){ //given a list of event objects, return the top 3 categories
	existing = {};
	data.forEach(function(event) {
			event.issues.forEach(function(issue) {
				if (!(issue in existing)) {
					existing[issue] = 1;
				} else {
					existing[issue] += 1
				}
			});
	});
	var topThree = [];	
	Object.keys(existing).forEach(function(key){
		topThree.push([key, existing[key]]);
	});
	topThree.sort(function(a, b) {return b[1] - a[1];});
	topThree = topThree.slice(0,3);
	topThree = topThree.map(function(e) {return e[0];});
	return topThree;
}
	

  </script>
</body>
</html>
